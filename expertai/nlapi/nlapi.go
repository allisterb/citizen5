// Package nlapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.11.0 DO NOT EDIT.
package nlapi

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

// Request
type AnalysisRequest struct {
	// Document
	Document *Document `json:"document,omitempty"`
}

// Analysis data
type AnalyzeDocument struct {
	// Analyzed text
	Content *string `json:"content,omitempty"`

	// Entities
	Entities *[]Entity `json:"entities,omitempty"`

	// Knowledge Graph syncons data
	Knowledge *[]KnowledgeEntry `json:"knowledge,omitempty"`

	// Text language
	Language *string `json:"language,omitempty"`

	// Main lemmas
	MainLemmas *[]MainLemma `json:"mainLemmas,omitempty"`

	// Main phrases
	MainPhrases *[]MainPhrase `json:"mainPhrases,omitempty"`

	// Main sentences
	MainSentences *[]MainSentence `json:"mainSentences,omitempty"`

	// Main syncons
	MainSyncons *[]MainSyncon `json:"mainSyncons,omitempty"`

	// Paragraphs
	Paragraphs *[]Paragraph `json:"paragraphs,omitempty"`

	// Phrases
	Phrases *[]Phrase `json:"phrases,omitempty"`

	// Verb-mediated relations
	Relations *[]Relation `json:"relations,omitempty"`

	// Sentences
	Sentences *[]Sentence `json:"sentences,omitempty"`

	// Sentiment
	Sentiment *struct {
		// Items expressing sentiment
		Items *[]SentimentItem `json:"items,omitempty"`

		// Text negativity
		Negativity *float32 `json:"negativity,omitempty"`

		// Overall text sentiment score
		Overall *float32 `json:"overall,omitempty"`

		// Text positivity
		Positivity *float32 `json:"positivity,omitempty"`
	} `json:"sentiment,omitempty"`

	// Tokens
	Tokens *[]Token `json:"tokens,omitempty"`

	// Knowledge Graph topics
	Topics *[]DocumentTopic `json:"topics,omitempty"`

	// Service version
	Version *string `json:"version,omitempty"`
}

// Analysis resource response
type AnalyzeResponse struct {
	// Analysis data
	Data *AnalyzeDocument `json:"data,omitempty"`

	// Service errors
	Errors *[]ServiceError `json:"errors,omitempty"`

	// Operation completed successfully (true/false)
	Success *bool `json:"success,omitempty"`
}

// Atom info
type Atom struct {
	// Zero-based position of the first character after the atom
	End *int64 `json:"end,omitempty"`

	// Lemma
	Lemma *string `json:"lemma,omitempty"`

	// Zero-based position of the first character of the atom
	Start *int64 `json:"start,omitempty"`

	// Expert.ai type
	Type *string `json:"type,omitempty"`
}

// Categorization data
type CategorizeDocument struct {
	// Categories
	Categories *[]Category `json:"categories,omitempty"`

	// Text language
	Language *string `json:"language,omitempty"`

	// Service version
	Version *string `json:"version,omitempty"`
}

// Classification resource response
type CategorizeResponse struct {
	// Categorization data
	Data *CategorizeDocument `json:"data,omitempty"`

	// Service errors
	Errors *[]ServiceError `json:"errors,omitempty"`

	// Operation completed successfully (true/false)
	Success *bool `json:"success,omitempty"`
}

// Category
type Category struct {
	// Score expressed as a percentage of the sum of the scores of all the candidate categories, winners and not (see the **score** property)
	Frequency *float32 `json:"frequency,omitempty"`

	// Hierarchical path
	Hierarchy *[]string `json:"hierarchy,omitempty"`

	// Category ID
	Id *string `json:"id,omitempty"`

	// Category label
	Label *string `json:"label,omitempty"`

	// Name of the software package containing the reference taxonomy
	Namespace *string `json:"namespace,omitempty"`

	// Positions of the portions of text that contributed to the selection of the category
	Positions *[]DocumentPosition `json:"positions,omitempty"`

	// Score assigned to the category to represent its relevance
	Score *int32 `json:"score,omitempty"`

	// True if the category is deemed particularly relevant
	Winner *bool `json:"winner,omitempty"`
}

// Information about a context
type ContextInfo struct {
	// Context description
	Description *string `json:"description,omitempty"`

	// Information about supported languages and available analyses
	Languages *[]ContextLanguageInfo `json:"languages,omitempty"`

	// Context name
	Name *string `json:"name,omitempty"`
}

// Information about a supported language and available analyses
type ContextLanguageInfo struct {
	// Available analyses
	Analyses *[]string `json:"analyses,omitempty"`

	// Language code
	Code *string `json:"code,omitempty"`

	// Language name
	Name *string `json:"name,omitempty"`
}

// Available contexts
type ContextsResponse struct {
	// List of contexts' information
	Contexts *[]ContextInfo `json:"contexts,omitempty"`
}

// Dependency info
type Dependency struct {
	// Number of the head token
	Head *int64 `json:"head,omitempty"`

	// Zero-based cardinal number of the token
	Id *int64 `json:"id,omitempty"`

	// (<a href='https://universaldependencies.org/u/dep/#universal-dependency-relations' target='_blank'>Dependency relation</a> between the token and the head token
	Label *string `json:"label,omitempty"`
}

// Summary information about a detector
type DetectorInfo struct {
	// OpenAPI document describing the use of the detector and its output
	Contract *string `json:"contract,omitempty"`

	// Detector description
	Description *string `json:"description,omitempty"`

	// Supported languages
	Languages *[]LanguageInfo `json:"languages,omitempty"`

	// Detector name
	Name *string `json:"name,omitempty"`
}

// Available detectors
type DetectorsResponse struct {
	// List of detectors' information
	Detectors *[]DetectorInfo `json:"detectors,omitempty"`
}

// Document
type Document struct {
	// The document's text
	Text *string `json:"text,omitempty"`
}

// Position
type DocumentPosition struct {
	// Zero-based position of the character after the last
	End *int64 `json:"end,omitempty"`

	// Zero-based position of the first character
	Start *int64 `json:"start,omitempty"`
}

// Knowledge Graph topic info
type DocumentTopic struct {
	// Language-independent topic ID
	Id *int64 `json:"id,omitempty"`

	// Topic name
	Label *string `json:"label,omitempty"`

	// Score assigned to the topic to represent its relevance
	Score *float32 `json:"score,omitempty"`

	// True if the topic is deemed particularly relevant
	Winner *bool `json:"winner,omitempty"`
}

// Entity info
type Entity struct {
	// Entity attributes inferred from the context or from the Knowledge Graph
	Attributes *[]InferredAttribute `json:"attributes,omitempty"`

	// Base form (lemma) of the entity name
	Lemma *string `json:"lemma,omitempty"`

	// Positions of the entity's mentions
	Positions *[]DocumentPosition `json:"positions,omitempty"`

	// Entity relevance
	Relevance *int64 `json:"relevance,omitempty"`

	// ID used to look up Knowledge Graph data in the `knowledge` array
	Syncon *int64 `json:"syncon,omitempty"`

	// Entity type
	Type *string `json:"type,omitempty"`
}

// Inferred attribute
type InferredAttribute struct {
	// Attribute name
	Attribute *string `json:"attribute,omitempty"`

	// Attribute's attributes
	Attributes *[]InferredAttribute `json:"attributes,omitempty"`

	// Lemma
	Lemma *string `json:"lemma,omitempty"`

	// ID used to look up Knowledge Graph data in the `knowledge` array
	Syncon *int64 `json:"syncon,omitempty"`

	// Attribute type
	Type *string `json:"type,omitempty"`
}

// Knowledge Graph data for a syncon
type KnowledgeEntry struct {
	// Textual rendering of the general conceptual category for the token in the Knowledge Graph
	Label *string `json:"label,omitempty"`

	// Syncon extended properties
	Properties *[]Property `json:"properties,omitempty"`

	// Syncon ID
	Syncon *int64 `json:"syncon,omitempty"`
}

// Information about a supported language
type LanguageInfo struct {
	// Language code
	Code *string `json:"code,omitempty"`

	// Language name
	Name *string `json:"name,omitempty"`
}

// Main lemma info
type MainLemma struct {
	// Positions of lemma occurrences
	Positions *[]DocumentPosition `json:"positions,omitempty"`

	// Score assigned to the lemma to represent its relevance
	Score *float32 `json:"score,omitempty"`

	// Lemma
	Value *string `json:"value,omitempty"`
}

// Main phrase info
type MainPhrase struct {
	// Positions of phrase occurrences
	Positions *[]DocumentPosition `json:"positions,omitempty"`

	// Score assigned to the phrase to represent its relevance
	Score *float32 `json:"score,omitempty"`

	// Phrase text
	Value *string `json:"value,omitempty"`
}

// Main sentence
type MainSentence struct {
	// Zero-based position of the first character after the sentence
	End *int64 `json:"end,omitempty"`

	// Score assigned to the sentence to represent its relevance
	Score *float32 `json:"score,omitempty"`

	// Zero-based position of the first character of the sentence
	Start *int64 `json:"start,omitempty"`

	// Sentence text
	Value *string `json:"value,omitempty"`
}

// Main syncon info
type MainSyncon struct {
	// Lemma
	Lemma *string `json:"lemma,omitempty"`

	// Positions of the expressions of the syncon
	Positions *[]DocumentPosition `json:"positions,omitempty"`

	// Score assigned to the syncon to represent its relevance
	Score *float32 `json:"score,omitempty"`

	// ID used to look up Knowledge Graph data in the `knowledge` array
	Syncon *int64 `json:"syncon,omitempty"`
}

// Paragraph info
type Paragraph struct {
	// Zero-based position of the first character after the paragraph
	End *int64 `json:"end,omitempty"`

	// Indexes (in the `sentences` array) of the sentences that make up the paragraph
	Sentences *[]int32 `json:"sentences,omitempty"`

	// Zero-based position of the first character of the paragraph
	Start *int64 `json:"start,omitempty"`
}

// Phrase info
type Phrase struct {
	// Zero-based position of the first character after the phrase
	End *int64 `json:"end,omitempty"`

	// Zero-based position of the first character of the phrase
	Start *int64 `json:"start,omitempty"`

	// Indexes (in the `tokens` array) of the tokens that make up the phrase
	Tokens *[]int32 `json:"tokens,omitempty"`

	// Phrase type
	Type *string `json:"type,omitempty"`
}

// Syncon property
type Property struct {
	// Property type
	Type *string `json:"type,omitempty"`

	// Property value
	Value *string `json:"value,omitempty"`
}

// In a relation, a term that's directly or indirectly related to the verb
type RelatedItem struct {
	// Lemma
	Lemma *string `json:"lemma,omitempty"`

	// Phrase index in the `phrases` array
	Phrase *int64 `json:"phrase,omitempty"`

	// Related terms
	Related *[]RelatedItem `json:"related,omitempty"`

	// Verb-item relation
	Relation *string `json:"relation,omitempty"`

	// Relevance
	Relevance *int64 `json:"relevance,omitempty"`

	// ID used to look up Knowledge Graph data in the `knowledge` array
	Syncon *int64 `json:"syncon,omitempty"`

	// Item text
	Text *string `json:"text,omitempty"`

	// Type
	Type *string `json:"type,omitempty"`

	// A concept that does not exist in the Knowledge Graph but heuristics recognized as a type of a known parent concept.
	Vsyn *VirtualSyncon `json:"vsyn,omitempty"`
}

// Verb-mediated relation
type Relation struct {
	// Related items
	Related *[]RelatedItem `json:"related,omitempty"`

	// Verb of a relation
	Verb *RelationVerb `json:"verb,omitempty"`
}

// Verb of a relation
type RelationVerb struct {
	// Lemma
	Lemma *string `json:"lemma,omitempty"`

	// Phrase index in the `phrases` array
	Phrase *int64 `json:"phrase,omitempty"`

	// Relevance
	Relevance *int64 `json:"relevance,omitempty"`

	// ID used to look up Knowledge Graph data in the `knowledge` array
	Syncon *int64 `json:"syncon,omitempty"`

	// Verb text
	Text *string `json:"text,omitempty"`

	// Type
	Type *string `json:"type,omitempty"`
}

// Sentence info
type Sentence struct {
	// Zero-based position of the first character after the sentence
	End *int64 `json:"end,omitempty"`

	// Indexes (in the `phrases` array) of the phrases that make up the sentence
	Phrases *[]int32 `json:"phrases,omitempty"`

	// Zero-based position of the first character of the sentence
	Start *int64 `json:"start,omitempty"`
}

// Item or chain of items expressing sentiment
type SentimentItem struct {
	// Items expressing sentiment
	Items *[]SentimentItem `json:"items,omitempty"`

	// Lemma
	Lemma *string `json:"lemma,omitempty"`

	// Item/chain sentiment score
	Sentiment *float32 `json:"sentiment,omitempty"`

	// ID used to look up Knowledge Graph data in the `knowledge` array
	Syncon *int64 `json:"syncon,omitempty"`
}

// Error information
type ServiceError struct {
	// Error code
	Code *string `json:"code,omitempty"`

	// Error message
	Message *string `json:"message,omitempty"`
}

// Available taxonomies
type TaxonomiesResponse struct {
	// List of taxonomies' information
	Texonomies *[]TaxonomyInfo `json:"texonomies,omitempty"`
}

// A taxonomy's categories tree
type Taxonomy struct {
	// Name of the software package containing the reference taxonomy
	Namespace *string `json:"namespace,omitempty"`

	// Categories tree
	Taxonomy *[]TaxonomyCategory `json:"taxonomy,omitempty"`
}

// Taxonomy category
type TaxonomyCategory struct {
	// Sub-categories
	Categories *[]TaxonomyCategory `json:"categories,omitempty"`

	// Category ID
	Id *string `json:"id,omitempty"`

	// Category label
	Label *string `json:"label,omitempty"`
}

// Summary information about a taxonomy
type TaxonomyInfo struct {
	// OpenAPI document describing extra ways to use the taxonomy and their outputs
	Contract *string `json:"contract,omitempty"`

	// Taxonomy description
	Description *string `json:"description,omitempty"`

	// Supported languages
	Languages *[]LanguageInfo `json:"languages,omitempty"`

	// Taxonomy name
	Name *string `json:"name,omitempty"`
}

// Taxonomy categories
type TaxonomyResponse struct {
	Data *[]Taxonomy `json:"data,omitempty"`

	// Service errors
	Errors *[]ServiceError `json:"errors,omitempty"`

	// Operation completed successfully (true/false)
	Success *bool `json:"success,omitempty"`
}

// Token info
type Token struct {
	// Atoms that make up the token
	Atoms *[]Atom `json:"atoms,omitempty"`

	// Dependency info
	Dependency *Dependency `json:"dependency,omitempty"`

	// Zero-based position of the first character after the token
	End *int64 `json:"end,omitempty"`

	// Lemma
	Lemma *string `json:"lemma,omitempty"`

	// A semicolon separated list of <a href='https://universaldependencies.org/format.html#morphological-annotation'>CoNLL-U format</a> morphological features
	Morphology *string `json:"morphology,omitempty"`

	// Paragraph index in the `paragraphs` array
	Paragraph *int64 `json:"paragraph,omitempty"`

	// Phrase index in the `phrases` array
	Phrase *int64 `json:"phrase,omitempty"`

	// <a href='https://universaldependencies.org/u/pos/'>Universal Dependencies part-of-speech tag</a>
	Pos *string `json:"pos,omitempty"`

	// Sentence index in the `sentences` array
	Sentence *int64 `json:"sentence,omitempty"`

	// Zero-based position of the first character of the token
	Start *int64 `json:"start,omitempty"`

	// ID used to look up Knowledge Graph data in the `knowledge` array
	Syncon *int64 `json:"syncon,omitempty"`

	// Expert.ai type
	Type *string `json:"type,omitempty"`

	// A concept that does not exist in the Knowledge Graph but heuristics recognized as a type of a known parent concept.
	Vsyn *VirtualSyncon `json:"vsyn,omitempty"`
}

// A concept that does not exist in the Knowledge Graph but heuristics recognized as a type of a known parent concept.
type VirtualSyncon struct {
	// ID used to mark all the occurrences of the virtual concept in the text
	Id *int64 `json:"id,omitempty"`

	// Parent concept; ID is used to look up Knowledge Graph data in the `knowledge` array
	Parent *int64 `json:"parent,omitempty"`
}

// Available contexts
type N200Contexts = ContextsResponse

// Available detectors
type N200Detectors = DetectorsResponse

// Available taxonomies
type N200Taxonomies = TaxonomiesResponse

// Taxonomy categories
type N200Taxonomy = TaxonomyResponse

// PostAnalyzeContextLanguageJSONBody defines parameters for PostAnalyzeContextLanguage.
type PostAnalyzeContextLanguageJSONBody = AnalysisRequest

// PostAnalyzeContextLanguageParamsLanguage defines parameters for PostAnalyzeContextLanguage.
type PostAnalyzeContextLanguageParamsLanguage string

// PostAnalyzeContextLanguageAnalysisJSONBody defines parameters for PostAnalyzeContextLanguageAnalysis.
type PostAnalyzeContextLanguageAnalysisJSONBody = AnalysisRequest

// PostAnalyzeContextLanguageAnalysisParamsLanguage defines parameters for PostAnalyzeContextLanguageAnalysis.
type PostAnalyzeContextLanguageAnalysisParamsLanguage string

// PostAnalyzeContextLanguageAnalysisParamsAnalysis defines parameters for PostAnalyzeContextLanguageAnalysis.
type PostAnalyzeContextLanguageAnalysisParamsAnalysis string

// PostCategorizeTaxonomyLanguageJSONBody defines parameters for PostCategorizeTaxonomyLanguage.
type PostCategorizeTaxonomyLanguageJSONBody = AnalysisRequest

// PostCategorizeTaxonomyLanguageParamsLanguage defines parameters for PostCategorizeTaxonomyLanguage.
type PostCategorizeTaxonomyLanguageParamsLanguage string

// PostDetectDetectorLanguageJSONBody defines parameters for PostDetectDetectorLanguage.
type PostDetectDetectorLanguageJSONBody = AnalysisRequest

// PostDetectDetectorLanguageParamsLanguage defines parameters for PostDetectDetectorLanguage.
type PostDetectDetectorLanguageParamsLanguage string

// GetTaxonomiesTaxonomyLanguageParamsLanguage defines parameters for GetTaxonomiesTaxonomyLanguage.
type GetTaxonomiesTaxonomyLanguageParamsLanguage string

// PostAnalyzeContextLanguageJSONRequestBody defines body for PostAnalyzeContextLanguage for application/json ContentType.
type PostAnalyzeContextLanguageJSONRequestBody = PostAnalyzeContextLanguageJSONBody

// PostAnalyzeContextLanguageAnalysisJSONRequestBody defines body for PostAnalyzeContextLanguageAnalysis for application/json ContentType.
type PostAnalyzeContextLanguageAnalysisJSONRequestBody = PostAnalyzeContextLanguageAnalysisJSONBody

// PostCategorizeTaxonomyLanguageJSONRequestBody defines body for PostCategorizeTaxonomyLanguage for application/json ContentType.
type PostCategorizeTaxonomyLanguageJSONRequestBody = PostCategorizeTaxonomyLanguageJSONBody

// PostDetectDetectorLanguageJSONRequestBody defines body for PostDetectDetectorLanguage for application/json ContentType.
type PostDetectDetectorLanguageJSONRequestBody = PostDetectDetectorLanguageJSONBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// PostAnalyzeContextLanguage request with any body
	PostAnalyzeContextLanguageWithBody(ctx context.Context, context string, language PostAnalyzeContextLanguageParamsLanguage, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostAnalyzeContextLanguage(ctx context.Context, context string, language PostAnalyzeContextLanguageParamsLanguage, body PostAnalyzeContextLanguageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostAnalyzeContextLanguageAnalysis request with any body
	PostAnalyzeContextLanguageAnalysisWithBody(ctx context.Context, context string, language PostAnalyzeContextLanguageAnalysisParamsLanguage, analysis PostAnalyzeContextLanguageAnalysisParamsAnalysis, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostAnalyzeContextLanguageAnalysis(ctx context.Context, context string, language PostAnalyzeContextLanguageAnalysisParamsLanguage, analysis PostAnalyzeContextLanguageAnalysisParamsAnalysis, body PostAnalyzeContextLanguageAnalysisJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostCategorizeTaxonomyLanguage request with any body
	PostCategorizeTaxonomyLanguageWithBody(ctx context.Context, taxonomy string, language PostCategorizeTaxonomyLanguageParamsLanguage, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostCategorizeTaxonomyLanguage(ctx context.Context, taxonomy string, language PostCategorizeTaxonomyLanguageParamsLanguage, body PostCategorizeTaxonomyLanguageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetContexts request
	GetContexts(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostDetectDetectorLanguage request with any body
	PostDetectDetectorLanguageWithBody(ctx context.Context, detector string, language PostDetectDetectorLanguageParamsLanguage, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostDetectDetectorLanguage(ctx context.Context, detector string, language PostDetectDetectorLanguageParamsLanguage, body PostDetectDetectorLanguageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDetectors request
	GetDetectors(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTaxonomies request
	GetTaxonomies(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTaxonomiesTaxonomyLanguage request
	GetTaxonomiesTaxonomyLanguage(ctx context.Context, taxonomy string, language GetTaxonomiesTaxonomyLanguageParamsLanguage, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) PostAnalyzeContextLanguageWithBody(ctx context.Context, context string, language PostAnalyzeContextLanguageParamsLanguage, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAnalyzeContextLanguageRequestWithBody(c.Server, context, language, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAnalyzeContextLanguage(ctx context.Context, context string, language PostAnalyzeContextLanguageParamsLanguage, body PostAnalyzeContextLanguageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAnalyzeContextLanguageRequest(c.Server, context, language, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAnalyzeContextLanguageAnalysisWithBody(ctx context.Context, context string, language PostAnalyzeContextLanguageAnalysisParamsLanguage, analysis PostAnalyzeContextLanguageAnalysisParamsAnalysis, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAnalyzeContextLanguageAnalysisRequestWithBody(c.Server, context, language, analysis, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAnalyzeContextLanguageAnalysis(ctx context.Context, context string, language PostAnalyzeContextLanguageAnalysisParamsLanguage, analysis PostAnalyzeContextLanguageAnalysisParamsAnalysis, body PostAnalyzeContextLanguageAnalysisJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAnalyzeContextLanguageAnalysisRequest(c.Server, context, language, analysis, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCategorizeTaxonomyLanguageWithBody(ctx context.Context, taxonomy string, language PostCategorizeTaxonomyLanguageParamsLanguage, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCategorizeTaxonomyLanguageRequestWithBody(c.Server, taxonomy, language, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCategorizeTaxonomyLanguage(ctx context.Context, taxonomy string, language PostCategorizeTaxonomyLanguageParamsLanguage, body PostCategorizeTaxonomyLanguageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCategorizeTaxonomyLanguageRequest(c.Server, taxonomy, language, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetContexts(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetContextsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostDetectDetectorLanguageWithBody(ctx context.Context, detector string, language PostDetectDetectorLanguageParamsLanguage, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostDetectDetectorLanguageRequestWithBody(c.Server, detector, language, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostDetectDetectorLanguage(ctx context.Context, detector string, language PostDetectDetectorLanguageParamsLanguage, body PostDetectDetectorLanguageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostDetectDetectorLanguageRequest(c.Server, detector, language, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDetectors(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDetectorsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTaxonomies(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTaxonomiesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTaxonomiesTaxonomyLanguage(ctx context.Context, taxonomy string, language GetTaxonomiesTaxonomyLanguageParamsLanguage, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTaxonomiesTaxonomyLanguageRequest(c.Server, taxonomy, language)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewPostAnalyzeContextLanguageRequest calls the generic PostAnalyzeContextLanguage builder with application/json body
func NewPostAnalyzeContextLanguageRequest(server string, context string, language PostAnalyzeContextLanguageParamsLanguage, body PostAnalyzeContextLanguageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostAnalyzeContextLanguageRequestWithBody(server, context, language, "application/json", bodyReader)
}

// NewPostAnalyzeContextLanguageRequestWithBody generates requests for PostAnalyzeContextLanguage with any type of body
func NewPostAnalyzeContextLanguageRequestWithBody(server string, context string, language PostAnalyzeContextLanguageParamsLanguage, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "context", runtime.ParamLocationPath, context)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "language", runtime.ParamLocationPath, language)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/analyze/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostAnalyzeContextLanguageAnalysisRequest calls the generic PostAnalyzeContextLanguageAnalysis builder with application/json body
func NewPostAnalyzeContextLanguageAnalysisRequest(server string, context string, language PostAnalyzeContextLanguageAnalysisParamsLanguage, analysis PostAnalyzeContextLanguageAnalysisParamsAnalysis, body PostAnalyzeContextLanguageAnalysisJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostAnalyzeContextLanguageAnalysisRequestWithBody(server, context, language, analysis, "application/json", bodyReader)
}

// NewPostAnalyzeContextLanguageAnalysisRequestWithBody generates requests for PostAnalyzeContextLanguageAnalysis with any type of body
func NewPostAnalyzeContextLanguageAnalysisRequestWithBody(server string, context string, language PostAnalyzeContextLanguageAnalysisParamsLanguage, analysis PostAnalyzeContextLanguageAnalysisParamsAnalysis, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "context", runtime.ParamLocationPath, context)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "language", runtime.ParamLocationPath, language)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "analysis", runtime.ParamLocationPath, analysis)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/analyze/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostCategorizeTaxonomyLanguageRequest calls the generic PostCategorizeTaxonomyLanguage builder with application/json body
func NewPostCategorizeTaxonomyLanguageRequest(server string, taxonomy string, language PostCategorizeTaxonomyLanguageParamsLanguage, body PostCategorizeTaxonomyLanguageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostCategorizeTaxonomyLanguageRequestWithBody(server, taxonomy, language, "application/json", bodyReader)
}

// NewPostCategorizeTaxonomyLanguageRequestWithBody generates requests for PostCategorizeTaxonomyLanguage with any type of body
func NewPostCategorizeTaxonomyLanguageRequestWithBody(server string, taxonomy string, language PostCategorizeTaxonomyLanguageParamsLanguage, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "taxonomy", runtime.ParamLocationPath, taxonomy)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "language", runtime.ParamLocationPath, language)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/categorize/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetContextsRequest generates requests for GetContexts
func NewGetContextsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/contexts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostDetectDetectorLanguageRequest calls the generic PostDetectDetectorLanguage builder with application/json body
func NewPostDetectDetectorLanguageRequest(server string, detector string, language PostDetectDetectorLanguageParamsLanguage, body PostDetectDetectorLanguageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostDetectDetectorLanguageRequestWithBody(server, detector, language, "application/json", bodyReader)
}

// NewPostDetectDetectorLanguageRequestWithBody generates requests for PostDetectDetectorLanguage with any type of body
func NewPostDetectDetectorLanguageRequestWithBody(server string, detector string, language PostDetectDetectorLanguageParamsLanguage, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "detector", runtime.ParamLocationPath, detector)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "language", runtime.ParamLocationPath, language)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/detect/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDetectorsRequest generates requests for GetDetectors
func NewGetDetectorsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/detectors")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTaxonomiesRequest generates requests for GetTaxonomies
func NewGetTaxonomiesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/taxonomies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTaxonomiesTaxonomyLanguageRequest generates requests for GetTaxonomiesTaxonomyLanguage
func NewGetTaxonomiesTaxonomyLanguageRequest(server string, taxonomy string, language GetTaxonomiesTaxonomyLanguageParamsLanguage) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "taxonomy", runtime.ParamLocationPath, taxonomy)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "language", runtime.ParamLocationPath, language)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/taxonomies/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// PostAnalyzeContextLanguage request with any body
	PostAnalyzeContextLanguageWithBodyWithResponse(ctx context.Context, context string, language PostAnalyzeContextLanguageParamsLanguage, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAnalyzeContextLanguageResponse, error)

	PostAnalyzeContextLanguageWithResponse(ctx context.Context, context string, language PostAnalyzeContextLanguageParamsLanguage, body PostAnalyzeContextLanguageJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAnalyzeContextLanguageResponse, error)

	// PostAnalyzeContextLanguageAnalysis request with any body
	PostAnalyzeContextLanguageAnalysisWithBodyWithResponse(ctx context.Context, context string, language PostAnalyzeContextLanguageAnalysisParamsLanguage, analysis PostAnalyzeContextLanguageAnalysisParamsAnalysis, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAnalyzeContextLanguageAnalysisResponse, error)

	PostAnalyzeContextLanguageAnalysisWithResponse(ctx context.Context, context string, language PostAnalyzeContextLanguageAnalysisParamsLanguage, analysis PostAnalyzeContextLanguageAnalysisParamsAnalysis, body PostAnalyzeContextLanguageAnalysisJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAnalyzeContextLanguageAnalysisResponse, error)

	// PostCategorizeTaxonomyLanguage request with any body
	PostCategorizeTaxonomyLanguageWithBodyWithResponse(ctx context.Context, taxonomy string, language PostCategorizeTaxonomyLanguageParamsLanguage, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCategorizeTaxonomyLanguageResponse, error)

	PostCategorizeTaxonomyLanguageWithResponse(ctx context.Context, taxonomy string, language PostCategorizeTaxonomyLanguageParamsLanguage, body PostCategorizeTaxonomyLanguageJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCategorizeTaxonomyLanguageResponse, error)

	// GetContexts request
	GetContextsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetContextsResponse, error)

	// PostDetectDetectorLanguage request with any body
	PostDetectDetectorLanguageWithBodyWithResponse(ctx context.Context, detector string, language PostDetectDetectorLanguageParamsLanguage, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostDetectDetectorLanguageResponse, error)

	PostDetectDetectorLanguageWithResponse(ctx context.Context, detector string, language PostDetectDetectorLanguageParamsLanguage, body PostDetectDetectorLanguageJSONRequestBody, reqEditors ...RequestEditorFn) (*PostDetectDetectorLanguageResponse, error)

	// GetDetectors request
	GetDetectorsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDetectorsResponse, error)

	// GetTaxonomies request
	GetTaxonomiesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetTaxonomiesResponse, error)

	// GetTaxonomiesTaxonomyLanguage request
	GetTaxonomiesTaxonomyLanguageWithResponse(ctx context.Context, taxonomy string, language GetTaxonomiesTaxonomyLanguageParamsLanguage, reqEditors ...RequestEditorFn) (*GetTaxonomiesTaxonomyLanguageResponse, error)
}

type PostAnalyzeContextLanguageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AnalyzeResponse
}

// Status returns HTTPResponse.Status
func (r PostAnalyzeContextLanguageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAnalyzeContextLanguageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostAnalyzeContextLanguageAnalysisResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AnalyzeResponse
}

// Status returns HTTPResponse.Status
func (r PostAnalyzeContextLanguageAnalysisResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAnalyzeContextLanguageAnalysisResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostCategorizeTaxonomyLanguageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CategorizeResponse
}

// Status returns HTTPResponse.Status
func (r PostCategorizeTaxonomyLanguageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostCategorizeTaxonomyLanguageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetContextsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ContextsResponse
}

// Status returns HTTPResponse.Status
func (r GetContextsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetContextsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostDetectDetectorLanguageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PostDetectDetectorLanguageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostDetectDetectorLanguageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDetectorsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DetectorsResponse
}

// Status returns HTTPResponse.Status
func (r GetDetectorsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDetectorsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTaxonomiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TaxonomiesResponse
}

// Status returns HTTPResponse.Status
func (r GetTaxonomiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTaxonomiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTaxonomiesTaxonomyLanguageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TaxonomyResponse
}

// Status returns HTTPResponse.Status
func (r GetTaxonomiesTaxonomyLanguageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTaxonomiesTaxonomyLanguageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// PostAnalyzeContextLanguageWithBodyWithResponse request with arbitrary body returning *PostAnalyzeContextLanguageResponse
func (c *ClientWithResponses) PostAnalyzeContextLanguageWithBodyWithResponse(ctx context.Context, context string, language PostAnalyzeContextLanguageParamsLanguage, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAnalyzeContextLanguageResponse, error) {
	rsp, err := c.PostAnalyzeContextLanguageWithBody(ctx, context, language, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAnalyzeContextLanguageResponse(rsp)
}

func (c *ClientWithResponses) PostAnalyzeContextLanguageWithResponse(ctx context.Context, context string, language PostAnalyzeContextLanguageParamsLanguage, body PostAnalyzeContextLanguageJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAnalyzeContextLanguageResponse, error) {
	rsp, err := c.PostAnalyzeContextLanguage(ctx, context, language, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAnalyzeContextLanguageResponse(rsp)
}

// PostAnalyzeContextLanguageAnalysisWithBodyWithResponse request with arbitrary body returning *PostAnalyzeContextLanguageAnalysisResponse
func (c *ClientWithResponses) PostAnalyzeContextLanguageAnalysisWithBodyWithResponse(ctx context.Context, context string, language PostAnalyzeContextLanguageAnalysisParamsLanguage, analysis PostAnalyzeContextLanguageAnalysisParamsAnalysis, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAnalyzeContextLanguageAnalysisResponse, error) {
	rsp, err := c.PostAnalyzeContextLanguageAnalysisWithBody(ctx, context, language, analysis, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAnalyzeContextLanguageAnalysisResponse(rsp)
}

func (c *ClientWithResponses) PostAnalyzeContextLanguageAnalysisWithResponse(ctx context.Context, context string, language PostAnalyzeContextLanguageAnalysisParamsLanguage, analysis PostAnalyzeContextLanguageAnalysisParamsAnalysis, body PostAnalyzeContextLanguageAnalysisJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAnalyzeContextLanguageAnalysisResponse, error) {
	rsp, err := c.PostAnalyzeContextLanguageAnalysis(ctx, context, language, analysis, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAnalyzeContextLanguageAnalysisResponse(rsp)
}

// PostCategorizeTaxonomyLanguageWithBodyWithResponse request with arbitrary body returning *PostCategorizeTaxonomyLanguageResponse
func (c *ClientWithResponses) PostCategorizeTaxonomyLanguageWithBodyWithResponse(ctx context.Context, taxonomy string, language PostCategorizeTaxonomyLanguageParamsLanguage, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCategorizeTaxonomyLanguageResponse, error) {
	rsp, err := c.PostCategorizeTaxonomyLanguageWithBody(ctx, taxonomy, language, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCategorizeTaxonomyLanguageResponse(rsp)
}

func (c *ClientWithResponses) PostCategorizeTaxonomyLanguageWithResponse(ctx context.Context, taxonomy string, language PostCategorizeTaxonomyLanguageParamsLanguage, body PostCategorizeTaxonomyLanguageJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCategorizeTaxonomyLanguageResponse, error) {
	rsp, err := c.PostCategorizeTaxonomyLanguage(ctx, taxonomy, language, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCategorizeTaxonomyLanguageResponse(rsp)
}

// GetContextsWithResponse request returning *GetContextsResponse
func (c *ClientWithResponses) GetContextsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetContextsResponse, error) {
	rsp, err := c.GetContexts(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetContextsResponse(rsp)
}

// PostDetectDetectorLanguageWithBodyWithResponse request with arbitrary body returning *PostDetectDetectorLanguageResponse
func (c *ClientWithResponses) PostDetectDetectorLanguageWithBodyWithResponse(ctx context.Context, detector string, language PostDetectDetectorLanguageParamsLanguage, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostDetectDetectorLanguageResponse, error) {
	rsp, err := c.PostDetectDetectorLanguageWithBody(ctx, detector, language, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostDetectDetectorLanguageResponse(rsp)
}

func (c *ClientWithResponses) PostDetectDetectorLanguageWithResponse(ctx context.Context, detector string, language PostDetectDetectorLanguageParamsLanguage, body PostDetectDetectorLanguageJSONRequestBody, reqEditors ...RequestEditorFn) (*PostDetectDetectorLanguageResponse, error) {
	rsp, err := c.PostDetectDetectorLanguage(ctx, detector, language, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostDetectDetectorLanguageResponse(rsp)
}

// GetDetectorsWithResponse request returning *GetDetectorsResponse
func (c *ClientWithResponses) GetDetectorsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDetectorsResponse, error) {
	rsp, err := c.GetDetectors(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDetectorsResponse(rsp)
}

// GetTaxonomiesWithResponse request returning *GetTaxonomiesResponse
func (c *ClientWithResponses) GetTaxonomiesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetTaxonomiesResponse, error) {
	rsp, err := c.GetTaxonomies(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTaxonomiesResponse(rsp)
}

// GetTaxonomiesTaxonomyLanguageWithResponse request returning *GetTaxonomiesTaxonomyLanguageResponse
func (c *ClientWithResponses) GetTaxonomiesTaxonomyLanguageWithResponse(ctx context.Context, taxonomy string, language GetTaxonomiesTaxonomyLanguageParamsLanguage, reqEditors ...RequestEditorFn) (*GetTaxonomiesTaxonomyLanguageResponse, error) {
	rsp, err := c.GetTaxonomiesTaxonomyLanguage(ctx, taxonomy, language, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTaxonomiesTaxonomyLanguageResponse(rsp)
}

// ParsePostAnalyzeContextLanguageResponse parses an HTTP response from a PostAnalyzeContextLanguageWithResponse call
func ParsePostAnalyzeContextLanguageResponse(rsp *http.Response) (*PostAnalyzeContextLanguageResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostAnalyzeContextLanguageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AnalyzeResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostAnalyzeContextLanguageAnalysisResponse parses an HTTP response from a PostAnalyzeContextLanguageAnalysisWithResponse call
func ParsePostAnalyzeContextLanguageAnalysisResponse(rsp *http.Response) (*PostAnalyzeContextLanguageAnalysisResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostAnalyzeContextLanguageAnalysisResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AnalyzeResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostCategorizeTaxonomyLanguageResponse parses an HTTP response from a PostCategorizeTaxonomyLanguageWithResponse call
func ParsePostCategorizeTaxonomyLanguageResponse(rsp *http.Response) (*PostCategorizeTaxonomyLanguageResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostCategorizeTaxonomyLanguageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CategorizeResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetContextsResponse parses an HTTP response from a GetContextsWithResponse call
func ParseGetContextsResponse(rsp *http.Response) (*GetContextsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetContextsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ContextsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostDetectDetectorLanguageResponse parses an HTTP response from a PostDetectDetectorLanguageWithResponse call
func ParsePostDetectDetectorLanguageResponse(rsp *http.Response) (*PostDetectDetectorLanguageResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostDetectDetectorLanguageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetDetectorsResponse parses an HTTP response from a GetDetectorsWithResponse call
func ParseGetDetectorsResponse(rsp *http.Response) (*GetDetectorsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDetectorsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DetectorsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetTaxonomiesResponse parses an HTTP response from a GetTaxonomiesWithResponse call
func ParseGetTaxonomiesResponse(rsp *http.Response) (*GetTaxonomiesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTaxonomiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TaxonomiesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetTaxonomiesTaxonomyLanguageResponse parses an HTTP response from a GetTaxonomiesTaxonomyLanguageWithResponse call
func ParseGetTaxonomiesTaxonomyLanguageResponse(rsp *http.Response) (*GetTaxonomiesTaxonomyLanguageResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTaxonomiesTaxonomyLanguageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TaxonomyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}
